<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Simulador Hidrostático Pro</title>

  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React / ReactDOM CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <!-- Babel para transformar JSX al vuelo (solo en desarrollo, pero funciona perfecto en páginas estáticas) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    body {
      background: #eef2ff;
    }
    .input {
      @apply w-full p-2 border rounded-lg shadow-sm;
    }
    .btn {
      @apply px-4 py-2 rounded-lg font-semibold cursor-pointer;
    }
  </style>
</head>

<body class="min-h-screen p-6 flex justify-center items-start">

  <div id="root" class="w-full"></div>

  <!-- Tu simulador React Pro, convertido en un archivo build-ready -->
  <script type="text/babel">

    const { useState, useRef, useEffect } = React;

    function App() {

      const [rho, setRho] = useState(1000);
      const [g, setG] = useState(9.81);
      const [h, setH] = useState(2);
      const [area, setArea] = useState(1);
      const [steps, setSteps] = useState(50);

      const canvasRef = useRef(null);

      const P0 = 101325;
      const pressureAt = depth => P0 + rho * g * depth;

      const hc = h / 2;
      const F = rho * g * hc * area;

      useEffect(() => {
        draw();
      }, [rho, g, h, area, steps]);

      function draw() {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext("2d");

        const DPR = window.devicePixelRatio || 1;

        const W = canvas.clientWidth * DPR;
        const H = canvas.clientHeight * DPR;
        canvas.width = W;
        canvas.height = H;

        ctx.clearRect(0, 0, W, H);

        const fluidLeft = 40 * DPR;
        const fluidTop = 20 * DPR;
        const fluidWidth = W * 0.4;
        const fluidHeight = H - 40 * DPR;

        // Fluido
        const grad = ctx.createLinearGradient(0, fluidTop, 0, fluidTop + fluidHeight);
        grad.addColorStop(0, "#bfe8ff");
        grad.addColorStop(1, "#1e90ff");
        ctx.fillStyle = grad;
        ctx.fillRect(fluidLeft, fluidTop, fluidWidth, fluidHeight);

        const maxBarWidth = W * 0.25;

        for (let i = 0; i <= steps; i++) {
          const frac = i / steps;
          const y = fluidTop + frac * fluidHeight;
          const P = pressureAt(h * frac);
          const rel = (P - P0) / (rho * g * h || 1);
          const barW = rel * maxBarWidth;

          ctx.fillStyle = "rgba(255,255,255,0.3)";
          ctx.fillRect(fluidLeft + fluidWidth + 20 * DPR, y - 3 * DPR, barW, 6 * DPR);

          if (i % Math.ceil(steps / 6) === 0) {
            ctx.fillStyle = "#012";
            ctx.font = `${13 * DPR}px Inter`;
            ctx.fillText(`${(frac * h).toFixed(2)} m`, fluidLeft + fluidWidth + barW + 40 * DPR, y + 4);
          }
        }

        // Pared
       // Separación más amplia entre barra de presión y pared
const separation = W * 0.15;

// NUEVA posición de la pared (más a la derecha)
const wallX = fluidLeft + fluidWidth + separation + maxBarWidth;

// Pared vertical
const wallW = W * 0.08;
ctx.fillStyle = "#e5e7eb";
ctx.fillRect(wallX, fluidTop, wallW, fluidHeight);
ctx.strokeStyle = "#cbd5e1";
ctx.strokeRect(wallX, fluidTop, wallW, fluidHeight);

// Centroide Y
const yCp = fluidTop + (hc / h) * fluidHeight;

// Flecha de fuerza
const maxVector = W * 0.22;
const vec = Math.min(maxVector, (F / (rho * g * h * area || 1)) * maxVector);

ctx.strokeStyle = "#ef4444";
ctx.lineWidth = 3 * DPR;
ctx.beginPath();
ctx.moveTo(wallX + wallW + 12 * DPR, yCp);
ctx.lineTo(wallX + wallW + 12 * DPR + vec, yCp);
ctx.stroke();

ctx.fillStyle = "#ef4444";
ctx.beginPath();
ctx.moveTo(wallX + wallW + 12 * DPR + vec, yCp);
ctx.lineTo(wallX + wallW + 8 * DPR + vec, yCp - 6 * DPR);
ctx.lineTo(wallX + wallW + 8 * DPR + vec, yCp + 6 * DPR);
ctx.closePath();
ctx.fill();

        ctx.strokeStyle = "#c5c5c5";
        ctx.strokeRect(wallX, fluidTop, wallW, fluidHeight);

        const yCp = fluidTop + (hc / h) * fluidHeight;
        const maxVector = 180 * DPR;
        const vec = Math.min(maxVector, (F / (rho * g * h * area || 1)) * maxVector);

        // Flecha
        ctx.strokeStyle = "#ff4d2e";
        ctx.lineWidth = 3 * DPR;
        ctx.beginPath();
        ctx.moveTo(wallX + wallW + 10 * DPR, yCp);
        ctx.lineTo(wallX + wallW + 10 * DPR + vec, yCp);
        ctx.stroke();

        ctx.fillStyle = "#ff4d2e";
        ctx.beginPath();
        ctx.moveTo(wallX + wallW + 10 * DPR + vec, yCp);
        ctx.lineTo(wallX + wallW + vec, yCp - 6 * DPR);
        ctx.lineTo(wallX + wallW + vec, yCp + 6 * DPR);
        ctx.closePath();
        ctx.fill();
      }

      const download = () => {
        const a = document.createElement("a");
        a.href = canvasRef.current.toDataURL("image/png");
        a.download = "simulacion_hidrostatica.png";
        a.click();
      };

      return (
        <div className="max-w-6xl w-full grid grid-cols-1 lg:grid-cols-3 gap-6">

          {/* Panel */}
          <div className="bg-white p-5 rounded-xl shadow-md flex flex-col gap-3">
            <h2 className="text-xl font-bold">Parámetros</h2>
            <p className="text-gray-600 text-sm">
              Modifica los valores para visualizar cómo cambia la presión y la fuerza.
            </p>

            <label>ρ (kg/m³)</label>
            <input type="number" className="input" value={rho} onChange={e => setRho(+e.target.value)} />

            <label>g (m/s²)</label>
            <input type="number" className="input" value={g} onChange={e => setG(+e.target.value)} />

            <label>h (m)</label>
            <input type="number" className="input" value={h} onChange={e => setH(+e.target.value)} />

            <label>A (m²)</label>
            <input type="number" className="input" value={area} onChange={e => setArea(+e.target.value)} />

            <label>Resolución</label>
            <input type="range" min={8} max={120} value={steps} onChange={e => setSteps(+e.target.value)} />

            <button className="btn bg-indigo-600 text-white" onClick={download}>Descargar imagen</button>
          </div>

          {/* Visualización */}
          <div className="lg:col-span-2 flex flex-col gap-6">
          <div className="bg-white p-4 rounded-xl shadow-md flex justify-center">
            <canvas
              ref={canvasRef}
              className="w-[95%] max-w-[800px] h-[420px] rounded-lg"
            />
          </div>


            {/* Resultados */}
            <div className="bg-white p-4 rounded-xl shadow-md">
              <h2 className="text-lg font-bold mb-2">Resultados</h2>
              <p><strong>Presión en la base:</strong> {Math.round(pressureAt(h))} Pa</p>
              <p><strong>Fuerza total:</strong> {F.toFixed(2)} N</p>
              <p><strong>Centroide:</strong> {hc.toFixed(2)} m</p>
            </div>
          </div>

        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<App />);
  </script>
</body>
</html>
