<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Simulador Hidrostático — Educativo</title>
<style>
  :root{
    --bg: #f6f9ff;
    --card: #ffffff;
    --muted: #6b7280;
    --accent: #3b82f6;
    --accent-2: #60a5fa;
    --good: #10b981;
    --danger: #ef4444;
    --shadow: 0 8px 20px rgba(11, 22, 60, 0.06);
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  *{box-sizing:border-box}
  body{margin:0;background:linear-gradient(180deg,var(--bg),#eef6ff 95%);padding:18px;color:#0b1220}
  .app{max-width:1200px;margin:0 auto;display:grid;grid-template-columns:320px 1fr;gap:20px}
  .panel{background:var(--card);border-radius:12px;padding:16px;box-shadow:var(--shadow)}
  .sidebar{height:calc(100vh - 40px);overflow:auto}
  h1{margin:0;font-size:20px}
  .muted{color:var(--muted);font-size:13px}
  .control{margin-top:12px}
  label{display:block;font-weight:600;font-size:13px;margin-bottom:6px}
  input[type=number]{width:100%;padding:8px;border-radius:8px;border:1px solid #e6eefb;background:#fff}
  input[type=range]{width:100%}
  .buttons{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
  button{cursor:pointer;border:0;padding:9px 12px;border-radius:8px;font-weight:700}
  .btn-primary{background:var(--accent);color:white}
  .btn-ghost{background:transparent;border:1px solid #e6eefb}
  .btn-soft{background:#f1f8ff;color:var(--accent)}
  .small{font-size:13px;color:var(--muted)}
  .main{display:flex;flex-direction:column;gap:14px}
  .canvas-area{display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap}
  canvas{background:transparent;border-radius:8px}
  #visCanvas{width:100%;height:460px;border-radius:8px;background:linear-gradient(180deg,#f7fbff,#eaf6ff)}
  #chartCanvas{width:360px;height:220px;border-radius:8px;background:white}
  .results{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
  .result-card{background:#fff;padding:10px;border-radius:8px;box-shadow:var(--shadow)}
  footer.small{color:var(--muted);margin-top:12px}
  @media(max-width:980px){
    .app{grid-template-columns:1fr;padding:12px}
    .sidebar{height:auto;order:2}
    .main{order:1}
    #chartCanvas{width:100%}
  }
</style>
</head>
<body>
  <div class="app">
    <aside class="panel sidebar">
      <h1>Simulador Hidrostático (educativo)</h1>
      <p class="small muted">Simulación dinámica: presiones, fuerza resultante y curva P(h). Usa los botones de caso para ejecutar los ejemplos del trabajo.</p>

      <div class="control">
        <label for="rho">Densidad ρ (kg/m³)</label>
        <input id="rho" type="number" value="1000" step="any" min="0">
      </div>
      <div class="control">
        <label for="g">Gravedad g (m/s²)</label>
        <input id="g" type="number" value="9.81" step="any" min="0">
      </div>
      <div class="control">
        <label for="h">Altura objetivo h (m)</label>
        <input id="h" type="number" value="2" step="any" min="0">
      </div>
      <div class="control">
        <label for="area">Área A (m²)</label>
        <input id="area" type="number" value="1" step="any" min="0">
      </div>
      <div class="control">
        <label for="steps">Resolución (líneas de presión)</label>
        <input id="steps" type="range" min="8" max="120" value="40">
      </div>

      <div class="control">
        <label for="speed">Velocidad</label>
        <input id="speed" type="range" min="0.25" max="3" step="0.05" value="1">
        <div class="small">Velocidad: <span id="speedTxt">1.00x</span></div>
      </div>

      <div class="buttons">
        <button id="case1" class="btn-primary">Caso 1 (Agua)</button>
        <button id="case2" class="btn-soft">Caso 2 (Aceite)</button>
      </div>

      <div class="buttons" style="margin-top:10px">
        <button id="start" class="btn-primary">Iniciar</button>
        <button id="pause" class="btn-ghost">Pausar</button>
        <button id="reset" class="btn-ghost">Reiniciar</button>
      </div>

      <div class="buttons" style="margin-top:10px">
        <button id="download" class="btn-soft">Descargar imagen</button>
        <button id="copy" class="btn-ghost">Copiar parámetros</button>
      </div>

      <div class="info small" style="margin-top:12px">
        <strong>Notas</strong>
        <ul>
          <li>P = P<sub>0</sub> + ρ g h</li>
          <li>F = ρ g h<sub>c</sub> A (h<sub>c</sub>=h/2)</li>
          <li>Pulsa <em>Iniciar</em> o usa los botones de caso.</li>
        </ul>
      </div>

      <footer class="small">Hecho para LRPD · 2025</footer>
    </aside>

    <main class="main panel">
      <div class="canvas-area">
        <div style="flex:1">
          <canvas id="visCanvas"></canvas>
          <div style="display:flex;justify-content:space-between;margin-top:8px">
            <div class="small">Nivel: <strong id="lvl">0.00 m</strong></div>
            <div class="small">Presión base: <strong id="pbase">101325 Pa</strong></div>
          </div>
        </div>

        <div style="width:360px">
          <canvas id="chartCanvas"></canvas>
          <div style="margin-top:8px" class="small">Curva: Presión vs Profundidad</div>
        </div>
      </div>

      <div class="results" style="margin-top:6px">
        <div class="result-card">
          <div class="small">Presión (base)</div>
          <div id="resP" style="font-weight:800;font-size:18px">—</div>
        </div>
        <div class="result-card">
          <div class="small">Fuerza total (F)</div>
          <div id="resF" style="font-weight:800;font-size:18px">—</div>
        </div>
        <div class="result-card">
          <div class="small">Centroide (h<sub>c</sub>)</div>
          <div id="resHc" style="font-weight:800;font-size:18px">—</div>
        </div>
        <div class="result-card">
          <div class="small">Parámetros</div>
          <div id="resParams" style="font-size:13px;color:var(--muted)">—</div>
        </div>
      </div>
    </main>
  </div>

<script>
/*
  Simulación educativa completa — JavaScript puro
  - animación de llenado
  - presión dinámica (barras)
  - flecha de fuerza animada
  - gráfico P(h) dibujado en canvas
  - botones Caso 1 / Caso 2, Start / Pause / Reset
*/

(function(){
  // DOM elements
  const vis = document.getElementById('visCanvas');
  const chart = document.getElementById('chartCanvas');
  const DPR = window.devicePixelRatio || 1;
  const ctx = vis.getContext('2d');
  const cctx = chart.getContext('2d');

  // controls
  const rhoEl = document.getElementById('rho');
  const gEl = document.getElementById('g');
  const hEl = document.getElementById('h');
  const areaEl = document.getElementById('area');
  const stepsEl = document.getElementById('steps');
  const speedEl = document.getElementById('speed');
  const speedTxt = document.getElementById('speedTxt');

  const startBtn = document.getElementById('start');
  const pauseBtn = document.getElementById('pause');
  const resetBtn = document.getElementById('reset');
  const downloadBtn = document.getElementById('download');
  const copyBtn = document.getElementById('copy');

  const case1Btn = document.getElementById('case1');
  const case2Btn = document.getElementById('case2');

  // results
  const resP = document.getElementById('resP');
  const resF = document.getElementById('resF');
  const resHc = document.getElementById('resHc');
  const resParams = document.getElementById('resParams');
  const lvlLabel = document.getElementById('lvl');
  const pbaseLabel = document.getElementById('pbase');

  // state
  let anim = false;
  let last = null;
  let progress = 0; // 0..1
  const baseDuration = 2.2; // seconds to fill at speed=1
  const P0 = 101325;

  // resize canvases
  function resizeAll(){
    const r = vis.getBoundingClientRect();
    vis.width = Math.max(600, Math.round(r.width * DPR));
    vis.height = Math.max(360, Math.round(r.height * DPR));

    const rc = chart.getBoundingClientRect();
    chart.width = Math.round(rc.width * DPR);
    chart.height = Math.round(rc.height * DPR);

    draw(); drawChart(); // redraw
  }
  window.addEventListener('resize', resizeAll);
  setTimeout(resizeAll,60);

  // util
  function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
  function fmt(x,unit){ if(Math.abs(x)>=1000) return (x/1000).toFixed(2)+' k'+(unit||''); return (Math.round(x*100)/100)+' '+(unit||'') }

  // physics helpers
  function pressureAt(depth, rho, g){ return P0 + rho * g * depth; }
  function finalForce(rho,g,h,A){ const hc=h/2; return rho*g*hc*A; }

  // main draw
  function draw(){
    // read controls
    const rho = parseFloat(rhoEl.value)||0;
    const g = parseFloat(gEl.value)||9.81;
    const h = parseFloat(hEl.value)||0;
    const A = parseFloat(areaEl.value)||0;
    const steps = parseInt(stepsEl.value)||30;

    // derived
    const currentLevel = progress * h;
    const hc = h/2;
    const Ffinal = finalForce(rho,g,h,A);
    const PbaseFinal = pressureAt(h,rho,g);

    // update result panel (final values)
    resP.textContent = fmt(Math.round(PbaseFinal),'Pa');
    resF.textContent = fmt(Math.round(Ffinal),'N');
    resHc.textContent = fmt(hc,'m');
    resParams.textContent = `ρ=${rho} kg/m³ · g=${g} m/s² · h=${h} m · A=${A} m²`;

    lvlLabel.textContent = currentLevel.toFixed(2)+' m';
    const Pcurrent = pressureAt(currentLevel,rho,g);
    pbaseLabel.textContent = Math.round(Pcurrent)+' Pa';

    // draw main visualization
    const W = vis.width, H = vis.height;
    ctx.clearRect(0,0,W,H);
    ctx.save();

    const pad = 28 * DPR;
    const fluidLeft = pad;
    const fluidTop = pad;
    const fluidWidth = Math.round(W * 0.45);
    const fluidHeight = Math.round(H - pad*2);

    // fluid gradient
    const grad = ctx.createLinearGradient(0, fluidTop, 0, fluidTop + fluidHeight);
    grad.addColorStop(0, '#dff3ff');
    grad.addColorStop(1, '#9fd6ff');
    ctx.fillStyle = grad;
    ctx.fillRect(fluidLeft, fluidTop, fluidWidth, fluidHeight);

    // base grid lightly
    ctx.fillStyle = 'rgba(255,255,255,0.04)';
    const lines = Math.min(80, Math.max(8, steps));
    for(let i=0;i<lines;i++){
      const y = fluidTop + (i/lines) * fluidHeight;
      ctx.fillRect(fluidLeft, y, fluidWidth, 1 * DPR);
    }

    // filled region (current)
    const levelFrac = h===0?0:clamp(currentLevel/h,0,1);
    const fillH = levelFrac * fluidHeight;
    const yTopFill = fluidTop + fluidHeight - fillH;

    if(fillH>0){
      // darker overlay for filled portion
      ctx.fillStyle = 'rgba(0,80,160,0.14)';
      ctx.fillRect(fluidLeft, yTopFill, fluidWidth, fillH);

      // horizontal wave line (simple animated effect)
      const t = performance.now() / 300;
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      for(let i=0;i<Math.ceil(fluidWidth/30);i++){
        const x = fluidLeft + (i*30 + (t%30));
        ctx.fillRect(x, yTopFill - 3*DPR, 20, 3*DPR);
      }
    }

    // pressure bars (animated growth proportional to fill)
    const maxBarW = Math.round(W * 0.28);
    ctx.textBaseline = 'middle';
    ctx.font = `${12*DPR}px Inter`;

    for(let i=0;i<=steps;i++){
      const frac = i/steps;
      const depth = frac * h;
      const y = fluidTop + frac * fluidHeight;
      const P = pressureAt(depth,rho,g);
      // only show bars up to currentLevel (simulate progressive appearance)
      const visible = (frac <= levelFrac + 1/steps);
      const rel = (P - P0) / (rho * g * Math.max(1,h)) || 0;
      const targetBar = rel * maxBarW;
      // animate bar growth based on levelFrac
      const barW = visible ? targetBar * (levelFrac) : 0;

      ctx.fillStyle = 'rgba(255,255,255,0.28)';
      ctx.fillRect(fluidLeft + fluidWidth + 14 * DPR, y - 4*DPR, barW, 8*DPR);

      if(i % Math.ceil(steps/6) === 0){
        ctx.fillStyle = '#063';
        ctx.fillText(`${depth.toFixed(2)} m`, fluidLeft + fluidWidth + barW + 20 * DPR, y);
        ctx.fillText(`${Math.round(P)} Pa`, fluidLeft + fluidWidth + barW + 78 * DPR, y);
      }
    }

    // wall to right
    const wallX = fluidLeft + fluidWidth + Math.round(W * 0.22) + maxBarW;
    const wallW = Math.round(W * 0.09);
    ctx.fillStyle = '#fbfcfd';
    ctx.fillRect(wallX, fluidTop, wallW, fluidHeight);
    ctx.strokeStyle = '#e6eef6';
    ctx.strokeRect(wallX, fluidTop, wallW, fluidHeight);

    // draw center-of-pressure marker for current filled portion
    const hc_current = currentLevel/2;
    const yCp = (fillH>0) ? (fluidTop + fluidHeight - (hc_current / Math.max(h,0.0001)) * fluidHeight) : (fluidTop + fluidHeight);

    // force vector proportional to current integrated force
    // approximate current force as rho*g*(hc_current)*A (valid for rectangle partial fill)
    const Fcurrent = rho * g * hc_current * A;
    const vecMax = Math.min(W*0.22, 260*DPR);
    const vec = (Ffinal === 0) ? 0 : (Fcurrent / Math.max(1,Ffinal)) * vecMax;

    // arrow (growing)
    ctx.strokeStyle = 'rgba(239,68,68,0.95)';
    ctx.lineWidth = 3 * DPR;
    ctx.beginPath();
    ctx.moveTo(wallX + wallW + 10 * DPR, yCp);
    ctx.lineTo(wallX + wallW + 10 * DPR + vec, yCp);
    ctx.stroke();

    ctx.fillStyle = 'rgba(239,68,68,0.95)';
    ctx.beginPath();
    ctx.moveTo(wallX + wallW + 10 * DPR + vec, yCp);
    ctx.lineTo(wallX + wallW + vec, yCp - 6 * DPR);
    ctx.lineTo(wallX + wallW + vec, yCp + 6 * DPR);
    ctx.closePath();
    ctx.fill();

    // label values near arrow when visible
    if(vec>2){
      ctx.fillStyle = '#082';
      ctx.font = `${13*DPR}px Inter`;
      ctx.fillText(`F = ${Math.round(Ffinal * (levelFrac))} N`, wallX + wallW + 12 * DPR + vec + 6 * DPR, yCp - 8 * DPR);
    }

    // header labels
    ctx.fillStyle = '#042';
    ctx.font = `${14*DPR}px Inter`;
    ctx.fillText(`h = ${h} m`, fluidLeft, fluidTop - 12*DPR);
    ctx.fillText(`ρ = ${rho} kg/m³`, fluidLeft + 120*DPR, fluidTop - 12*DPR);

    ctx.restore();
  }

  // draw pressure vs depth chart (simple)
  function drawChart(){
    const W = chart.width, H = chart.height;
    cctx.clearRect(0,0,W,H);
    cctx.save();
    cctx.scale(1,1);
    // read params
    const rho = parseFloat(rhoEl.value)||0;
    const g = parseFloat(gEl.value)||9.81;
    const h = parseFloat(hEl.value)||0;
    const steps = parseInt(stepsEl.value)||30;

    // margins
    const padL = 40 * DPR, padR = 12 * DPR, padT = 12 * DPR, padB = 28 * DPR;
    const plotW = W - padL - padR, plotH = H - padT - padB;

    // axis
    cctx.strokeStyle = '#e6eef6';
    cctx.fillStyle = '#073';
    cctx.lineWidth = 1;
    cctx.beginPath();
    cctx.moveTo(padL, padT);
    cctx.lineTo(padL, padT + plotH);
    cctx.lineTo(padL + plotW, padT + plotH);
    cctx.stroke();

    // compute points
    const maxP = pressureAt(h,rho,g);
    // draw grid + labels
    cctx.fillStyle = '#889598';
    cctx.font = `${11*DPR}px Inter`;
    for(let i=0;i<=4;i++){
      const y = padT + (i/4)*plotH;
      cctx.strokeStyle = 'rgba(0,0,0,0.03)';
      cctx.beginPath();
      cctx.moveTo(padL, y);
      cctx.lineTo(padL + plotW, y);
      cctx.stroke();
      const pVal = Math.round(maxP - (i/4)* (maxP - P0));
      cctx.fillText(pVal+' Pa', 6*DPR, y+4);
    }

    // draw curve P(h) left->right increasing depth downwards
    cctx.beginPath();
    for(let i=0;i<=steps;i++){
      const frac = i/steps;
      const depth = frac * h;
      const P = pressureAt(depth,rho,g);
      const x = padL + (P - P0)/(maxP - P0 || 1) * plotW;
      const y = padT + frac * plotH;
      if(i===0) cctx.moveTo(x,y); else cctx.lineTo(x,y);
    }
    cctx.strokeStyle = 'rgba(59,130,246,0.95)';
    cctx.lineWidth = 2 * DPR;
    cctx.stroke();

    // marker for current level
    const currentLevel = progress * h;
    const fracC = (h===0)?0:currentLevel/h;
    const Pcur = pressureAt(currentLevel, rho,g);
    const xcur = padL + (Pcur - P0)/(maxP - P0 || 1) * plotW;
    const ycur = padT + fracC * plotH;
    cctx.fillStyle = '#ef4444';
    cctx.beginPath();
    cctx.arc(xcur,ycur,4*DPR,0,Math.PI*2);
    cctx.fill();

    // axes labels
    cctx.fillStyle = '#374151';
    cctx.font = `${12*DPR}px Inter`;
    cctx.fillText('Presión (Pa) →', padL + 6*DPR, padT + plotH + 18*DPR);
    cctx.fillText('Profundidad (m)', padL + plotW/2 - 30*DPR, padT + plotH + 33*DPR);
    cctx.restore();
  }

  // animation loop
  function loop(ts){
    if(!last) last = ts;
    const dt = (ts - last)/1000;
    last = ts;
    const speed = parseFloat(speedEl.value) || 1;
    speedTxt.textContent = speed.toFixed(2) + 'x';
    const target = baseDuration / speed;
    if(anim){
      progress += dt / target;
      if(progress >= 1){ progress = 1; anim = false; }
      draw();
      drawChart();
    } else {
      // still refresh chart/vis so marker updates on input change
      draw();
      drawChart();
    }
    requestAnimationFrame(loop);
  }

  // controls binding
  startBtn.addEventListener('click', ()=>{ if(progress>=1) progress=0; anim=true; last=null; });
  pauseBtn.addEventListener('click', ()=>{ anim=false; last=null; });
  resetBtn.addEventListener('click', ()=>{ anim=false; progress=0; last=null; draw(); drawChart(); });

  downloadBtn.addEventListener('click', ()=>{
    // produce composite image: vis + chart side by side
    const tmp = document.createElement('canvas');
    const w = vis.width + chart.width, h = Math.max(vis.height, chart.height);
    tmp.width = w; tmp.height = h;
    const tctx = tmp.getContext('2d');
    // draw white background
    tctx.fillStyle = '#fff'; tctx.fillRect(0,0,w,h);
    tctx.drawImage(vis,0,0);
    tctx.drawImage(chart,vis.width,0);
    const a = document.createElement('a');
    a.href = tmp.toDataURL('image/png');
    a.download = 'simulation_snapshot.png';
    a.click();
  });

  copyBtn.addEventListener('click', ()=>{
    const str = `rho=${rhoEl.value}, g=${gEl.value}, h=${hEl.value}, A=${areaEl.value}`;
    navigator.clipboard.writeText(str).then(()=>{ copyBtn.textContent = 'Copiado ✓'; setTimeout(()=>copyBtn.textContent='Copiar parámetros',900); }).catch(()=>{});
  });

  // preset cases
  case1Btn.addEventListener('click', ()=>{
    rhoEl.value = 1000; gEl.value = 9.81; hEl.value = 2; areaEl.value = 1;
    progress = 0; anim = true; last = null;
  });
  case2Btn.addEventListener('click', ()=>{
    rhoEl.value = 850; gEl.value = 9.81; hEl.value = 1.5; areaEl.value = 0.8;
    progress = 0; anim = true; last = null;
  });

  // input listeners -> update visuals immediately (do not reset progress)
  [rhoEl,gEl,hEl,areaEl,stepsEl,speedEl].forEach(el=>el.addEventListener('input', ()=>{
    if(parseFloat(hEl.value)<=0) progress=0;
    draw(); drawChart();
  }));

  // start loop
  requestAnimationFrame(loop);
  // initial draw
  draw(); drawChart();
  // resize once to ensure proper pixel sizes
  setTimeout(resizeAll,120);
})();
</script>
</body>
</html>
