<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Simulador Hidrostático — Dark Purple Soft</title>
<style>
  :root{
    --bg1: #120c20; /* top */
    --bg2: #1d1433; /* bottom */
    --panel: #2a2040;
    --panel-2: #342745;
    --muted: #bfb4d9;
    --muted-2: #a899c6;
    --text: #efe9ff;
    --accent: #9ab3ff; /* curve */
    --accent-2: #7df0c8; /* highlights */
    --force: #ff85b5; /* force arrow */
    --glow: rgba(157,114,200,0.14);
    --shadow: 0 10px 30px rgba(10,8,18,0.6);
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    min-height:100vh;
    background: linear-gradient(180deg,var(--bg1),var(--bg2));
    color:var(--text);
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    padding:20px;
  }

  .app{max-width:1200px;margin:0 auto;display:grid;grid-template-columns:320px 1fr;gap:20px}
  .panel{background:linear-gradient(180deg,var(--panel),var(--panel-2));border-radius:12px;padding:16px;box-shadow:var(--shadow);border:1px solid rgba(255,255,255,0.03)}
  .sidebar{height:calc(100vh - 40px);overflow:auto}
  h1{margin:0;font-size:18px;color:var(--text)}
  .muted{color:var(--muted);font-size:13px}
  .control{margin-top:12px}
  label{display:block;font-weight:600;font-size:13px;margin-bottom:6px;color:var(--muted-2)}
  input[type=number]{width:100%;padding:9px;border-radius:9px;border:1px solid rgba(255,255,255,0.04);background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));color:var(--text)}
  input[type=range]{width:100%}
  .buttons{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
  button{cursor:pointer;border:0;padding:9px 12px;border-radius:9px;font-weight:700;background:transparent;color:var(--text)}
  .btn-primary{background:linear-gradient(90deg,var(--accent),#7fb8ff);color:#0b1b2b;box-shadow:0 6px 18px rgba(55,95,195,0.12)}
  .btn-soft{background:rgba(125,240,200,0.12);color:var(--accent-2)}
  .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.04)}
  .small{font-size:13px;color:var(--muted)}
  .main{display:flex;flex-direction:column;gap:14px}
  .canvas-area{display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap}
  #visCanvas{width:100%;height:460px;border-radius:10px;background:linear-gradient(180deg,#1b1230,#26173f)}
  #chartCanvas{width:360px;height:260px;border-radius:10px;background:linear-gradient(180deg,#241533,#2d1a3b)}
  .results{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
  .result-card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.02)}
  .result-card .label{font-size:12px;color:var(--muted-2)}
  .result-card .value{font-weight:800;font-size:18px;color:var(--text)}
  footer.small{color:var(--muted);margin-top:12px}
  .hint{font-size:12px;color:var(--muted);margin-top:8px}
  @media(max-width:980px){
    .app{grid-template-columns:1fr;padding:12px}
    .sidebar{height:auto;order:2}
    .main{order:1}
    #chartCanvas{width:100%}
  }
</style>
</head>
<body>
  <div class="app">
    <aside class="panel sidebar">
      <h1>Simulador Hidrostático — Educativo</h1>
      <p class="muted" style="margin-top:6px">Simulación dinámica con curva P(h), presiones animadas y fuerza resultante. Usa los botones de caso para ejecutar los ejemplos del trabajo.</p>

      <div class="control">
        <label for="rho">Densidad ρ (kg/m³)</label>
        <input id="rho" type="number" value="1000" step="any" min="0">
      </div>
      <div class="control">
        <label for="g">Gravedad g (m/s²)</label>
        <input id="g" type="number" value="9.81" step="any" min="0">
      </div>
      <div class="control">
        <label for="h">Altura objetivo h (m)</label>
        <input id="h" type="number" value="2" step="any" min="0">
      </div>
      <div class="control">
        <label for="area">Área A (m²)</label>
        <input id="area" type="number" value="1" step="any" min="0">
      </div>
      <div class="control">
        <label for="steps">Resolución (líneas)</label>
        <input id="steps" type="range" min="8" max="120" value="40">
      </div>

      <div class="control">
        <label for="speed">Velocidad</label>
        <input id="speed" type="range" min="0.25" max="3" step="0.05" value="1">
        <div class="small">Velocidad: <span id="speedTxt">1.00x</span></div>
      </div>

      <div class="buttons" style="margin-top:10px">
        <button id="case1" class="btn-primary">Caso 1 (Agua)</button>
        <button id="case2" class="btn-soft">Caso 2 (Aceite)</button>
      </div>

      <div class="buttons" style="margin-top:10px">
        <button id="start" class="btn-primary">Iniciar</button>
        <button id="pause" class="btn-ghost">Pausar</button>
        <button id="reset" class="btn-ghost">Reiniciar</button>
      </div>

      <div class="buttons" style="margin-top:10px">
        <button id="download" class="btn-soft">Descargar imagen</button>
        <button id="copy" class="btn-ghost">Copiar parámetros</button>
      </div>

      <div class="hint">
        <strong>Notas</strong>
        <ul style="padding-left:18px;margin:6px 0;color:var(--muted)">
          <li>P = P<sub>0</sub> + ρ g h</li>
          <li>F = ρ g h<sub>c</sub> A (h<sub>c</sub>=h/2)</li>
          <li>Pulsa <em>Iniciar</em> o usa los botones de caso.</li>
        </ul>
      </div>

      <footer class="small">Hecho para LRPD · 2025</footer>
    </aside>

    <main class="main panel">
      <div class="canvas-area">
        <div style="flex:1">
          <canvas id="visCanvas"></canvas>
          <div style="display:flex;justify-content:space-between;margin-top:10px">
            <div class="small">Nivel: <strong id="lvl">0.00 m</strong></div>
            <div class="small">Presión en base: <strong id="pbase">101325 Pa</strong></div>
          </div>
        </div>

        <div style="width:360px">
          <canvas id="chartCanvas"></canvas>
          <div style="margin-top:8px" class="small">Curva: Presión vs Profundidad</div>
        </div>
      </div>

      <div class="results">
        <div class="result-card">
          <div class="label">Presión (base)</div>
          <div id="resP" class="value">—</div>
        </div>
        <div class="result-card">
          <div class="label">Fuerza total (F)</div>
          <div id="resF" class="value">—</div>
        </div>
        <div class="result-card">
          <div class="label">Centroide (h<sub>c</sub>)</div>
          <div id="resHc" class="value">—</div>
        </div>
        <div class="result-card">
          <div class="label">Parámetros</div>
          <div id="resParams" class="small">—</div>
        </div>
      </div>
    </main>
  </div>

<script>
/* Simulación educativa — Dark Purple Soft
   HTML + CSS + JS puro — GitHub Pages friendly
*/
(function(){
  // canvas & contexts
  const vis = document.getElementById('visCanvas');
  const chart = document.getElementById('chartCanvas');
  const ctx = vis.getContext('2d');
  const cctx = chart.getContext('2d');
  const DPR = window.devicePixelRatio || 1;

  // controls
  const rhoEl = document.getElementById('rho');
  const gEl = document.getElementById('g');
  const hEl = document.getElementById('h');
  const areaEl = document.getElementById('area');
  const stepsEl = document.getElementById('steps');
  const speedEl = document.getElementById('speed');
  const speedTxt = document.getElementById('speedTxt');

  const startBtn = document.getElementById('start');
  const pauseBtn = document.getElementById('pause');
  const resetBtn = document.getElementById('reset');
  const downloadBtn = document.getElementById('download');
  const copyBtn = document.getElementById('copy');

  const case1Btn = document.getElementById('case1');
  const case2Btn = document.getElementById('case2');

  // results
  const resP = document.getElementById('resP');
  const resF = document.getElementById('resF');
  const resHc = document.getElementById('resHc');
  const resParams = document.getElementById('resParams');
  const lvlLabel = document.getElementById('lvl');
  const pbaseLabel = document.getElementById('pbase');

  // state
  let anim = false;
  let last = null;
  let progress = 0; // 0..1
  const baseDuration = 2.2; // seconds for speed=1
  const P0 = 101325;

  // resizing
  function resizeAll(){
    const r = vis.getBoundingClientRect();
    vis.width = Math.max(640, Math.round(r.width * DPR));
    vis.height = Math.max(380, Math.round((r.height || 460) * DPR));

    const rc = chart.getBoundingClientRect();
    chart.width = Math.round(rc.width * DPR || 360 * DPR);
    chart.height = Math.round(rc.height * DPR || 260 * DPR);

    draw(); drawChart();
  }
  window.addEventListener('resize', resizeAll);
  setTimeout(resizeAll, 60);

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function fmt(x, unit){
    if(Math.abs(x) >= 1000) return (x/1000).toFixed(2) + 'k' + (unit||'');
    return (Math.round(x*100)/100) + ' ' + (unit||'');
  }

  // physics functions
  function pressureAt(depth, rho, g){ return P0 + rho * g * depth; }
  function finalForce(rho,g,h,A){ const hc = h/2; return rho*g*hc*A; }

  // draw main visualization
  function draw(){
    const rho = parseFloat(rhoEl.value) || 0;
    const g = parseFloat(gEl.value) || 9.81;
    const h = parseFloat(hEl.value) || 0;
    const A = parseFloat(areaEl.value) || 0;
    const steps = parseInt(stepsEl.value) || 30;

    const currentLevel = progress * h;
    const hc = h/2;
    const Ffinal = finalForce(rho,g,h,A);
    const PbaseFinal = pressureAt(h, rho, g);

    // results panel (final)
    resP.textContent = fmt(Math.round(PbaseFinal),'Pa');
    resF.textContent = fmt(Math.round(Ffinal),'N');
    resHc.textContent = fmt(hc,'m');
    resParams.textContent = `ρ=${rho} kg/m³ · g=${g} m/s² · h=${h} m · A=${A} m²`;

    lvlLabel.textContent = currentLevel.toFixed(2) + ' m';
    const Pcurrent = pressureAt(currentLevel, rho, g);
    pbaseLabel.textContent = Math.round(Pcurrent) + ' Pa';

    // canvas dims
    const W = vis.width, H = vis.height;
    ctx.clearRect(0,0,W,H);
    ctx.save();

    // layout
    const pad = 30 * DPR;
    const fluidLeft = pad;
    const fluidTop = pad;
    const fluidWidth = Math.round(W * 0.46);
    const fluidHeight = Math.round(H - pad*2);

    // background (subtle)
    // fluid box
    const grad = ctx.createLinearGradient(0, fluidTop, 0, fluidTop + fluidHeight);
    grad.addColorStop(0, '#dff3ff');
    grad.addColorStop(1, '#9fd6ff');
    ctx.fillStyle = grad;
    // rounded rect for fluid container (soft border)
    roundRect(ctx, fluidLeft - 2*DPR, fluidTop - 2*DPR, fluidWidth + 4*DPR, fluidHeight + 4*DPR, 8*DPR);
    ctx.fill();

    // subtle inner shading for container
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    roundRectFill(ctx, fluidLeft, fluidTop, fluidWidth, fluidHeight, 6*DPR);

    // grid lines inside fluid
    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    const lines = Math.min(120, Math.max(8, steps));
    for(let i=0;i<lines;i++){
      const y = fluidTop + (i/lines) * fluidHeight;
      ctx.fillRect(fluidLeft + 6*DPR, y, fluidWidth - 12*DPR, 1 * DPR);
    }

    // filled region
    const levelFrac = h === 0 ? 0 : clamp(currentLevel / h, 0, 1);
    const fillH = Math.round(levelFrac * fluidHeight);
    const yTopFill = fluidTop + fluidHeight - fillH;

    if(fillH > 0){
      // overlay filled
      ctx.save();
      ctx.beginPath();
      roundRectPath(ctx, fluidLeft, yTopFill, fluidWidth, fillH, 6*DPR);
      ctx.clip();

      // gradient for filled area (deeper color)
      const fgrad = ctx.createLinearGradient(0, yTopFill, 0, yTopFill + fillH);
      fgrad.addColorStop(0, 'rgba(65,120,190,0.18)');
      fgrad.addColorStop(1, 'rgba(24,64,110,0.28)');
      ctx.fillStyle = fgrad;
      ctx.fillRect(fluidLeft, yTopFill, fluidWidth, fillH);

      // animated wave lines (subtle)
      const t = performance.now() / 350;
      ctx.fillStyle = 'rgba(255,255,255,0.03)';
      for(let i=0;i<Math.ceil(fluidWidth/40);i++){
        const x = fluidLeft + (i*40 + (t%40));
        ctx.fillRect(x, yTopFill + (Math.sin((i+t)/6) * 2 * DPR), 24, 2*DPR);
      }
      ctx.restore();
    }

    // pressure bars to the right of fluid (animated growth)
    const maxBarW = Math.round(W * 0.28);
    ctx.textBaseline = 'middle';
    ctx.font = `${12 * DPR}px Inter`;
    for(let i=0;i<=steps;i++){
      const frac = i/steps;
      const depth = frac * h;
      const y = fluidTop + frac * fluidHeight;
      const P = pressureAt(depth, parseFloat(rhoEl.value)||0, parseFloat(gEl.value)||9.81);
      const rel = (P - P0) / ( (parseFloat(rhoEl.value)||0) * (parseFloat(gEl.value)||9.81) * Math.max(0.0001,h) ) || 0;
      const targetBar = rel * maxBarW;
      // visibility depends on levelFrac: bars "grow" as level rises
      const visible = (frac <= levelFrac + 1/steps);
      const barW = visible ? targetBar * (levelFrac) : 0;

      // draw bar
      ctx.fillStyle = 'rgba(255,255,255,0.18)';
      roundRectFill(ctx, fluidLeft + fluidWidth + 16*DPR, y - 4*DPR, barW, 8*DPR, 4*DPR);

      // labels (left-shifted so curve won't overlap)
      if(i % Math.ceil(steps/6) === 0){
        ctx.fillStyle = 'rgba(200,220,255,0.9)';
        ctx.fillText(`${depth.toFixed(2)} m`, fluidLeft + fluidWidth + barW + 26*DPR, y);
        ctx.fillStyle = 'rgba(200,200,220,0.85)';
        ctx.fillText(`${Math.round(P)} Pa`, fluidLeft + fluidWidth + barW + 110*DPR, y);
      }
    }

    // wall to right (surface)
    const wallX = fluidLeft + fluidWidth + Math.round(W * 0.22) + maxBarW;
    const wallW = Math.round(W * 0.095);
    ctx.fillStyle = '#fbfcfd';
    ctx.globalAlpha = 0.95;
    roundRectFill(ctx, wallX, fluidTop, wallW, fluidHeight, 6*DPR);
    ctx.globalAlpha = 1;
    ctx.strokeStyle = 'rgba(30,30,40,0.04)';
    roundRectStroke(ctx, wallX, fluidTop, wallW, fluidHeight, 6*DPR);

    // compute center of pressure for current fill (approx hc_current = currentLevel/2)
    const hc_current = currentLevel > 0 ? currentLevel / 2 : 0;
    const yCp = fillH > 0 ? (fluidTop + fluidHeight - (hc_current / Math.max(h,0.0001)) * fluidHeight) : (fluidTop + fluidHeight);

    // compute current force (approx)
    //const rho = parseFloat(rhoEl.value)||0;
    const g = parseFloat(gEl.value)||9.81;
    const Fcurrent = rho * g * hc_current * (parseFloat(areaEl.value)||0);
    const Ffinal = finalForce(rho, g, h, parseFloat(areaEl.value)||0);

    const vecMax = Math.min(W * 0.22, 260 * DPR);
    const vec = Ffinal === 0 ? 0 : (Fcurrent / Math.max(1, Ffinal)) * vecMax;

    // arrow with glow
    ctx.lineWidth = 3 * DPR;
    // glow
    ctx.shadowColor = 'rgba(255,133,181,0.14)';
    ctx.shadowBlur = 12 * DPR;
    ctx.strokeStyle = 'rgba(255,133,181,0.95)';
    ctx.beginPath();
    ctx.moveTo(wallX + wallW + 12 * DPR, yCp);
    ctx.lineTo(wallX + wallW + 12 * DPR + vec, yCp);
    ctx.stroke();
    // arrow head
    ctx.fillStyle = 'rgba(255,133,181,0.98)';
    ctx.beginPath();
    ctx.moveTo(wallX + wallW + 12 * DPR + vec, yCp);
    ctx.lineTo(wallX + wallW + vec + 6 * DPR, yCp - 7 * DPR);
    ctx.lineTo(wallX + wallW + vec + 6 * DPR, yCp + 7 * DPR);
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur = 0;

    // label near arrow (shifted to avoid overlap)
    if(vec > 4){
      ctx.fillStyle = 'rgba(240,240,250,0.95)';
      ctx.font = `${13 * DPR}px Inter`;
      ctx.fillText(`F ≈ ${Math.round(Fcurrent)} N`, wallX + wallW + 12 * DPR + vec + 10 * DPR, yCp - 10 * DPR);
    }

    // top labels
    ctx.fillStyle = 'rgba(235,230,255,0.96)';
    ctx.font = `${14 * DPR}px Inter`;
    ctx.fillText(`h = ${h} m`, fluidLeft, fluidTop - 12 * DPR);
    ctx.fillText(`ρ = ${rho} kg/m³`, fluidLeft + 120 * DPR, fluidTop - 12 * DPR);

    ctx.restore();
  }

  // chart: Pressure vs Depth (redesigned)
  function drawChart(){
    const W = chart.width, H = chart.height;
    cctx.clearRect(0,0,W,H);
    cctx.save();

    // read params
    //const rho = parseFloat(rhoEl.value)||0;
    const g = parseFloat(gEl.value)||9.81;
    const h = parseFloat(hEl.value)||0;
    const steps = Math.max(8, parseInt(stepsEl.value)||30);

    // margins
    const ml = 44 * DPR, mr = 12 * DPR, mt = 16 * DPR, mb = 30 * DPR;
    const pw = W - ml - mr, ph = H - mt - mb;

    // background for chart
    cctx.fillStyle = 'rgba(30,20,40,0.35)';
    cctx.fillRect(0,0,W,H);

    // axes lines
    cctx.strokeStyle = 'rgba(255,255,255,0.06)';
    cctx.lineWidth = 1;
    cctx.beginPath();
    cctx.moveTo(ml, mt);
    cctx.lineTo(ml, mt + ph);
    cctx.lineTo(ml + pw, mt + ph);
    cctx.stroke();

    // compute max P
    const Pmax = pressureAt(h, rho, g);
    // grid horizontal
    cctx.fillStyle = 'rgba(190,200,230,0.6)';
    cctx.font = `${11 * DPR}px Inter`;
    for(let i=0;i<=4;i++){
      const y = mt + (i/4) * ph;
      cctx.strokeStyle = 'rgba(255,255,255,0.03)';
      cctx.beginPath();
      cctx.moveTo(ml, y);
      cctx.lineTo(ml + pw, y);
      cctx.stroke();
      // label value at left
      const pVal = Math.round(Pmax - (i/4) * (Pmax - P0));
      cctx.fillStyle = 'rgba(200,210,240,0.9)';
      cctx.fillText(pVal + ' Pa', 6 * DPR, y + 4);
    }

    // draw curve (depth increasing downwards)
    cctx.beginPath();
    for(let i=0;i<=steps;i++){
      const frac = i/steps;
      const depth = frac * h;
      const P = pressureAt(depth, rho, g);
      const x = ml + ((P - P0) / (Pmax - P0 || 1)) * pw;
      const y = mt + frac * ph;
      if(i===0) cctx.moveTo(x,y); else cctx.lineTo(x,y);
    }
    cctx.strokeStyle = 'rgba(154,179,255,0.98)';
    cctx.lineWidth = 2.5 * DPR;
    cctx.stroke();

    // draw marker for current level
    const currentLevel = progress * h;
    const fracC = (h === 0) ? 0 : (currentLevel / h);
    const Pcur = pressureAt(currentLevel, rho, g);
    const xcur = ml + ((Pcur - P0) / (Pmax - P0 || 1)) * pw;
    const ycur = mt + fracC * ph;

    // halo
    cctx.beginPath();
    cctx.fillStyle = 'rgba(154,179,255,0.14)';
    cctx.arc(xcur, ycur, 8 * DPR, 0, Math.PI*2);
    cctx.fill();

    // central dot
    cctx.fillStyle = '#dff3ff';
    cctx.beginPath();
    cctx.arc(xcur, ycur, 3.5 * DPR, 0, Math.PI*2);
    cctx.fill();

    // label (not overlapping)
    cctx.font = `${12 * DPR}px Inter`;
    cctx.fillStyle = 'rgba(230,230,250,0.95)';
    const labelX = clamp(xcur + 12 * DPR, ml + 8*DPR, ml + pw - 60 * DPR);
    const labelY = clamp(ycur - 10 * DPR, mt + 10 * DPR, mt + ph - 12 * DPR);
    cctx.fillText(`${Math.round(Pcur)} Pa`, labelX, labelY);

    // axis labels bottom
    cctx.fillStyle = 'rgba(200,210,240,0.9)';
    cctx.font = `${11 * DPR}px Inter`;
    cctx.fillText('Profundidad 0 → h (abajo)', ml, mt + ph + 20 * DPR);
    cctx.fillText('Presión (Pa) →', ml + pw - 80 * DPR, mt + ph + 20 * DPR);

    cctx.restore();
  }

  // rounding helper
  function roundRect(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }
  function roundRectFill(ctx, x, y, w, h, r){
    roundRect(ctx, x, y, w, h, r);
    ctx.fill();
  }
  function roundRectStroke(ctx, x, y, w, h, r){
    roundRect(ctx, x, y, w, h, r);
    ctx.stroke();
  }
  function roundRectPath(ctx, x, y, w, h, r){
    roundRect(ctx, x, y, w, h, r);
  }

  // animation loop
  function loop(ts){
    if(!last) last = ts;
    const dt = (ts - last) / 1000;
    last = ts;
    const speed = parseFloat(speedEl.value) || 1;
    speedTxt.textContent = speed.toFixed(2) + 'x';
    const target = baseDuration / speed;
    if(anim){
      progress += dt / target;
      if(progress >= 1){ progress = 1; anim = false; }
    }
    draw();
    drawChart();
    requestAnimationFrame(loop);
  }

  // controls
  startBtn.addEventListener('click', ()=>{ if(progress >= 1) progress = 0; anim = true; last = null; });
  pauseBtn.addEventListener('click', ()=>{ anim = false; last = null; });
  resetBtn.addEventListener('click', ()=>{ anim = false; progress = 0; last = null; draw(); drawChart(); });

  downloadBtn.addEventListener('click', ()=>{
    const tmp = document.createElement('canvas');
    const w = vis.width + chart.width + 20 * DPR;
    const h = Math.max(vis.height, chart.height);
    tmp.width = w; tmp.height = h;
    const tctx = tmp.getContext('2d');
    // background
    tctx.fillStyle = '#1b1230';
    tctx.fillRect(0,0,w,h);
    tctx.drawImage(vis, 0, 0);
    tctx.drawImage(chart, vis.width + 20 * DPR, 0);
    const a = document.createElement('a');
    a.href = tmp.toDataURL('image/png');
    a.download = 'simulacion_hidrostatica_snapshot.png';
    a.click();
  });

  copyBtn.addEventListener('click', ()=>{
    const s = `rho=${rhoEl.value}, g=${gEl.value}, h=${hEl.value}, A=${areaEl.value}`;
    navigator.clipboard.writeText(s).then(()=>{ copyBtn.textContent = 'Copiado ✓'; setTimeout(()=>copyBtn.textContent='Copiar parámetros',900); }).catch(()=>{});
  });

  // preset cases
  case1Btn.addEventListener('click', ()=>{
    rhoEl.value = 1000; gEl.value = 9.81; hEl.value = 2; areaEl.value = 1;
    progress = 0; anim = true; last = null;
  });
  case2Btn.addEventListener('click', ()=>{
    rhoEl.value = 850; gEl.value = 9.81; hEl.value = 1.5; areaEl.value = 0.8;
    progress = 0; anim = true; last = null;
  });

  // live updates when params change
  [rhoEl,gEl,hEl,areaEl,stepsEl,speedEl].forEach(el=>{
    el.addEventListener('input', ()=>{
      const hval = parseFloat(hEl.value) || 0;
      if(hval === 0) progress = 0;
      if(progress > 1) progress = 1;
      draw(); drawChart();
    });
  });

  // init
  requestAnimationFrame(loop);
  setTimeout(resizeAll, 120);
})();
</script>
</body>
</html>

