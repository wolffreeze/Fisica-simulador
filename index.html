<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Simulador Hidrostático · Simulación</title>

  <style>
    :root{
      --bg:#f0f4ff;
      --card:#ffffff;
      --muted:#6b7280;
      --accent:#4f46e5;
      --accent-dark:#4338ca;
      --danger:#ef4444;
      --shadow: 0 8px 20px rgba(18,23,50,0.06);
      font-family: Inter, Roboto, "Segoe UI", system-ui, -apple-system, "Helvetica Neue", Arial;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background: linear-gradient(180deg,var(--bg),#eef2ff 90%);
      color:#0f172a;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      padding:18px;
      min-height:100vh;
    }

    .app{max-width:1200px;margin:0 auto;display:grid;grid-template-columns:320px 1fr;gap:20px}
    .sidebar{background:var(--card);border-radius:12px;padding:18px;box-shadow:var(--shadow);height:calc(100vh - 40px);overflow:auto}
    .sidebar h2{margin:0 0 6px 0;font-size:18px}
    .muted{color:var(--muted);font-size:13px}
    .control{margin-top:10px}
    .control label{display:block;font-weight:600;margin-bottom:6px;font-size:13px}
    .control input[type="number"]{width:100%;padding:8px;border-radius:8px;border:1px solid #e6e9f2;background:#fff}
    .control input[type="range"]{width:100%}
    .buttons{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
    .btn{padding:9px 12px;border-radius:8px;border:0;cursor:pointer;font-weight:700;background:#eef2ff;color:#0b1220}
    .btn.primary{background:var(--accent);color:#fff;box-shadow:0 6px 18px rgba(79,70,229,0.12)}
    .btn.ghost{background:transparent;border:1px solid #e6e9f2}
    .info{margin-top:12px;padding:12px;background:linear-gradient(180deg,#fbfdff,#fff);border-radius:10px;border:1px solid #f1f5f9;font-size:13px;color:var(--muted)}

    .main{display:flex;flex-direction:column;gap:16px}
    .canvas-wrap{background:var(--card);border-radius:12px;padding:14px;box-shadow:var(--shadow)}
    .sim-canvas{width:100%;height:460px;border-radius:8px;background:linear-gradient(180deg,#f7fbff,#e9f2ff)}
    .controls-row{display:flex;gap:8px;align-items:center;margin-top:10px;flex-wrap:wrap}
    .small{font-size:12px;color:var(--muted)}

    .results-card{background:var(--card);border-radius:12px;padding:14px;box-shadow:var(--shadow);display:flex;flex-direction:column;gap:8px}
    .row{display:flex;justify-content:space-between;padding:6px 0;border-bottom:1px dashed #f1f5f9}
    .row strong{font-weight:700}
    footer.small{font-size:12px;color:var(--muted);margin-top:8px}

    @media (max-width:980px){
      .app{grid-template-columns:1fr; padding:12px}
      .sidebar{height:auto;order:2}
      .main{order:1}
      .sim-canvas{height:360px}
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar">
      <h2>Simulador Hidrostático</h2>
      <p class="muted">Simulación dinámica (Start/Pause/Reset). Ajusta parámetros y ejecuta el experimento.</p>

      <div class="control">
        <label for="rho">Densidad ρ (kg/m³)</label>
        <input id="rho" type="number" value="1000" step="any" min="0">
      </div>

      <div class="control">
        <label for="g">Gravedad g (m/s²)</label>
        <input id="g" type="number" value="9.81" step="any" min="0">
      </div>

      <div class="control">
        <label for="h">Profundidad objetivo h (m)</label>
        <input id="h" type="number" value="2" step="any" min="0">
      </div>

      <div class="control">
        <label for="area">Área A (m²)</label>
        <input id="area" type="number" value="1" step="any" min="0">
      </div>

      <div class="control">
        <label for="steps">Resolución visual</label>
        <input id="steps" type="range" min="8" max="120" value="40">
        <div class="small muted">Más líneas = mayor detalle</div>
      </div>

      <div class="control">
        <label for="speed">Velocidad de simulación</label>
        <input id="speed" type="range" min="0.2" max="3" step="0.1" value="1">
        <div class="small muted">Velocidad actual: <span id="speedVal">1.0x</span></div>
      </div>

      <div class="buttons">
        <button id="btnStart" class="btn primary">Iniciar</button>
        <button id="btnPause" class="btn">Pausar</button>
        <button id="btnReset" class="btn ghost">Reiniciar</button>
        <button id="btnDownload" class="btn primary">Descargar imagen</button>
        <button id="btnCopy" class="btn">Copiar parámetros</button>
      </div>

      <div class="info">
        <strong>Notas rápidas</strong>
        <ul>
          <li>Presión: <code>P = P<sub>0</sub> + ρ g h</code></li>
          <li>Fuerza: <code>F = ρ g h<sub>c</sub> A</code> (h<sub>c</sub>=h/2 para pared rectangular)</li>
          <li>Pulsa <em>Iniciar</em> para ver el llenado y la evolución del empuje.</li>
        </ul>
      </div>

      <footer class="small">Hecho para tu LRPD · 2025</footer>
    </aside>

    <main class="main">
      <section class="canvas-wrap">
        <canvas id="canvas" class="sim-canvas" aria-label="Visualización de la simulación"></canvas>

        <div class="controls-row" style="margin-top:12px;">
          <div class="small muted">Nivel actual: <span id="levelLabel">0.00 m</span></div>
          <div style="flex:1"></div>
          <div class="small muted">Presión base actual: <span id="pLabel">101325 Pa</span></div>
        </div>
      </section>

      <section class="results-card">
        <h3>Resultados</h3>
        <div class="row"><span>Presión en la base:</span><strong id="resP">—</strong></div>
        <div class="row"><span>Fuerza total (F):</span><strong id="resF">—</strong></div>
        <div class="row"><span>Centroide (h<sub>c</sub>):</span><strong id="resHc">—</strong></div>
        <div class="row"><span>Parámetros:</span><small id="resParams" class="muted">—</small></div>
        <div style="margin-top:8px" class="small muted">Usa <strong>Descargar imagen</strong> para crear figuras para tu informe.</div>
      </section>
    </main>
  </div>

<script>
(function(){
  // DOM
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const rhoIn = document.getElementById('rho');
  const gIn = document.getElementById('g');
  const hIn = document.getElementById('h');
  const areaIn = document.getElementById('area');
  const stepsIn = document.getElementById('steps');
  const speedIn = document.getElementById('speed');
  const speedVal = document.getElementById('speedVal');

  const btnStart = document.getElementById('btnStart');
  const btnPause = document.getElementById('btnPause');
  const btnReset = document.getElementById('btnReset');
  const btnDownload = document.getElementById('btnDownload');
  const btnCopy = document.getElementById('btnCopy');

  const resP = document.getElementById('resP');
  const resF = document.getElementById('resF');
  const resHc = document.getElementById('resHc');
  const resParams = document.getElementById('resParams');
  const levelLabel = document.getElementById('levelLabel');
  const pLabel = document.getElementById('pLabel');

  const DPR = window.devicePixelRatio || 1;

  // simulation state
  let animating = false;
  let progress = 0; // 0..1 (level/h)
  let lastTime = null;
  let durationSec = 2; // base duration for fill at speed=1 (seconds)

  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(600, rect.width * DPR);
    canvas.height = Math.max(360, rect.height * DPR);
    draw(); // redraw on resize
  }
  window.addEventListener('resize', resizeCanvas);
  setTimeout(resizeCanvas,60);

  function clamp(v,min,max){ return Math.min(max,Math.max(min,v)); }

  function formatNum(x, unit){
    if(Math.abs(x) >= 1000) return (x/1000).toFixed(2) + ' k' + (unit||'');
    return (Math.round(x*100)/100) + ' ' + (unit||'');
  }

  function draw(){
    // read inputs
    const rho = parseFloat(rhoIn.value) || 0;
    const g = parseFloat(gIn.value) || 9.81;
    const h = parseFloat(hIn.value) || 0;
    const A = parseFloat(areaIn.value) || 0;
    const steps = parseInt(stepsIn.value) || 30;

    // current simulated level (m)
    const currentLevel = progress * h;

    const P0 = 101325;
    const pressureAt = (depth)=> P0 + rho * g * depth;
    const hc = h/2;
    const F_final = rho * g * hc * A;

    // compute current values (during animation use currentLevel)
    const P_current = pressureAt(currentLevel);
    // approximate current force: use h_c = currentLevel/2 for a partial fill (rectangular)
    const hc_current = currentLevel > 0 ? currentLevel/2 : 0;
    const F_current = rho * g * hc_current * A;

    // update results panel
    const Pbase_final = pressureAt(h);
    resP.textContent = formatNum(Math.round(Pbase_final), 'Pa');
    resF.textContent = formatNum(Math.round(F_final), 'N');
    resHc.textContent = formatNum(hc, 'm');
    resParams.textContent = `ρ=${rho} kg/m³ · g=${g} m/s² · h=${h} m · A=${A} m²`;

    levelLabel.textContent = currentLevel.toFixed(2) + ' m';
    pLabel.textContent = Math.round(P_current) + ' Pa';

    // draw canvas
    const W = canvas.width;
    const H = canvas.height;
    ctx.clearRect(0,0,W,H);

    // layout
    const pad = 32 * DPR;
    const fluidLeft = pad;
    const fluidTop = pad;
    const fluidWidth = Math.round(W * 0.45);
    const fluidHeight = Math.round(H - pad*2);

    // fluid background gradient
    const grad = ctx.createLinearGradient(0, fluidTop, 0, fluidTop + fluidHeight);
    grad.addColorStop(0, '#bfe8ff');
    grad.addColorStop(1, '#1e90ff');
    ctx.fillStyle = grad;
    ctx.fillRect(fluidLeft, fluidTop, fluidWidth, fluidHeight);

    // draw filled region proportional to currentLevel
    const levelFrac = h === 0 ? 0 : (currentLevel / h);
    const fillHeight = clamp(levelFrac,0,1) * fluidHeight;
    const yFillTop = fluidTop + fluidHeight - fillHeight;

    // overlay the filled portion slightly darker to highlight level
    ctx.fillStyle = 'rgba(0,60,150,0.08)';
    ctx.fillRect(fluidLeft, yFillTop, fluidWidth, fillHeight);

    // draw horizontal line marking current level
    if (fillHeight > 2) {
      ctx.strokeStyle = 'rgba(0,0,0,0.12)';
      ctx.lineWidth = Math.max(1, DPR);
      ctx.beginPath();
      ctx.moveTo(fluidLeft, yFillTop);
      ctx.lineTo(fluidLeft + fluidWidth, yFillTop);
      ctx.stroke();
    }

    // pressure bars to the right
    const maxBarWidth = Math.round(W * 0.25);
    ctx.textBaseline = 'middle';
    ctx.font = `${12 * DPR}px sans-serif`;
    for(let i=0;i<=steps;i++){
      const frac = i/steps;
      const depth = frac * h;
      const y = fluidTop + (frac * fluidHeight);
      const P = pressureAt(depth);
      const rel = (P - P0) / (rho * g * h || 1);
      const barW = Math.max(2 * DPR, rel * maxBarWidth * (fillHeight>0 ? 1 : 0)); // bars visible when any fill

      // bar background
      ctx.fillStyle = 'rgba(255,255,255,0.18)';
      ctx.fillRect(fluidLeft + fluidWidth + 12 * DPR, y-4*DPR, barW, 8*DPR);

      // labels at regular intervals
      if(i % Math.ceil(steps/6) === 0){
        ctx.fillStyle = '#033';
        ctx.fillText(`${depth.toFixed(2)} m`, fluidLeft + fluidWidth + barW + 18 * DPR, y);
        ctx.fillText(`${Math.round(P)} Pa`, fluidLeft + fluidWidth + barW + 78 * DPR, y);
      }
    }

    // wall (moved to the right to avoid overlap)
    const wallX = fluidLeft + fluidWidth + Math.round(W * 0.22) + maxBarWidth;
    const wallW = Math.round(W * 0.09);
    ctx.fillStyle = '#eceff1';
    ctx.fillRect(wallX, fluidTop, wallW, fluidHeight);
    ctx.strokeStyle = '#cfd8dc';
    ctx.strokeRect(wallX, fluidTop, wallW, fluidHeight);

    // draw current center of pressure (approx using hc_current within the current filled depth)
    const yCp = fillHeight>0 ? (fluidTop + fluidHeight - (hc_current / h) * fluidHeight) : (fluidTop + fluidHeight);
    // vector scaled to F_current relative to final F
    const maxVis = Math.min(W * 0.22, 240 * DPR);
    const vec = F_final === 0 ? 0 : (F_current / F_final) * maxVis;

    // draw arrow
    ctx.strokeStyle = 'rgba(239,68,68,0.95)';
    ctx.lineWidth = 3 * DPR;
    ctx.beginPath();
    ctx.moveTo(wallX + wallW + 10 * DPR, yCp);
    ctx.lineTo(wallX + wallW + 10 * DPR + vec, yCp);
    ctx.stroke();

    // arrow head
    ctx.fillStyle = 'rgba(239,68,68,0.95)';
    ctx.beginPath();
    ctx.moveTo(wallX + wallW + 10 * DPR + vec, yCp);
    ctx.lineTo(wallX + wallW + vec, yCp - 6 * DPR);
    ctx.lineTo(wallX + wallW + vec, yCp + 6 * DPR);
    ctx.closePath();
    ctx.fill();

    // labels
    ctx.fillStyle = '#031d3a';
    ctx.font = `${13 * DPR}px sans-serif`;
    ctx.fillText(`h = ${h} m`, fluidLeft, fluidTop - 12 * DPR);
    ctx.fillText(`ρ = ${rho} kg/m³`, fluidLeft + 120 * DPR, fluidTop - 12 * DPR);
  }

  // animation loop
  function animateFrame(ts){
    if(!lastTime) lastTime = ts;
    const dt = (ts - lastTime) / 1000;
    lastTime = ts;

    const speed = parseFloat(speedIn.value) || 1;
    speedVal.textContent = speed.toFixed(1) + 'x';

    // duration scaled by speed (lower speed -> slower)
    const targetDuration = durationSec / speed;

    if(animating){
      // progress increases until 1
      progress += dt / targetDuration;
      if(progress >= 1){
        progress = 1;
        animating = false;
      }
      draw();
    }
    // continue loop even if paused to keep UI responsive
    requestAnimationFrame(animateFrame);
  }

  // controls
  btnStart.addEventListener('click', ()=>{
    if(progress >= 1) progress = 0; // restart automatically if finished
    animating = true;
    lastTime = null;
  });
  btnPause.addEventListener('click', ()=> { animating = false; lastTime = null; });
  btnReset.addEventListener('click', ()=> { animating = false; progress = 0; lastTime = null; draw(); });

  btnDownload.addEventListener('click', ()=>{
    const data = canvas.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = data;
    a.download = 'simulacion_hidrostatica.png';
    a.click();
  });

  btnCopy.addEventListener('click', ()=>{
    const params = `rho=${rhoIn.value}, g=${gIn.value}, h=${hIn.value}, A=${areaIn.value}`;
    navigator.clipboard.writeText(params).then(()=>{
      btnCopy.textContent = 'Copiado ✓';
      setTimeout(()=> btnCopy.textContent = 'Copiar parámetros', 1200);
    }).catch(()=>{});
  });

  // redraw on input change (but don't reset progress)
  [rhoIn,gIn,hIn,areaIn,stepsIn,speedIn].forEach(el=>{
    el.addEventListener('input', ()=> {
      // when h changes, avoid weird progress >1 relative to new h: clamp progress
      const hval = parseFloat(hIn.value) || 0;
      if(hval === 0) progress = 0;
      if(progress>1) progress = 1;
      draw();
    });
  });

  // kick animation loop
  requestAnimationFrame(animateFrame);
  // initial draw
  draw();
})();
</script>
</body>
</html>
